* Cdn 原理 (输入域名到解析的过程)

  ```
  1.浏览器输入域名，首先在本地hosts文件中查询对域名的解析
  2.没有话去浏览器缓存中查询对域名的解析
  3.再没有去本地dns（优先级最高）中查询解析 (迭代查询由根dns 指定去哪个dns 中查询内容，递归查询类似本地dns只发送一次解析请求，最后被返回ip)，
  4.如果是cdn，会把配置的域名也就是 cname 解析成 对应的一个 gslb 的服务器地址，最后向这个glsb 发送请求
  5.如果不走cdn， 会对域名解析成的ip 的端口（默认80）发送请求 
  
  后面如果是 php，就是 nginx监听的80 -> php fpm （进程管理器） 9090 -> php进程处理
  ```
  
* redis 连接和mysql 连接 管理方式有什么区别

  ```
  redis 才用的是多路复用 io
  
  mysql 是通过连接池的形式 （核心是每个连接，每个session 的管理 。io 多路复用把 连接信息 都用一个进程去处理，后续可以 队列单进程处理，也可以多进程处理。 mysql 的核心压力是 支撑不了这么多组状态 （事务隔离级别，当前session））
  
  https://cloud.tencent.com/developer/article/1121745 这篇文章介绍了为什么db 不采用多路复用。
  ```

* dns 解析

  ```
  1.本地host 文件
  2.浏览器host缓存
  3.本都dns 解析 （迭代法）
  4.根dns解析 （返回给本地dns）
  5. 本地dns 去一级 二级 dns 寻找，寻找到了记录本地dns， 再返回给用户 域名对应的ip
  ```

* nginx 访问php

  ```
  php-fpm 模块，默认应该是 9000 （和 80 进程通信方式，tcp 或者 socket 文件 （那就必须在同一台 服务器上））
  
  连接信息 --》php-fpm(进程管理器)--》php解析 (进程处理请求，并发低，占用内存高。请求结束，进程结束，变量声明周期结束，没法使用本地缓存。代码的解析现在有opcode， 但也可以提一下)
  
  nginx 转发请求给 php-fpm, 走的fastcgi协议，转发的内容在 fastcgi.conf里面
  ```

  

* 网络5层模型

  ```
  应用层： http 计算机用户与网络之间的接口，
  
  传输层： tcp  udp  以及流控和差错校验，保证报文能正确传输。
  
  网络层： ip  路由选择算法，进行逻辑地址寻址，实现不同网络之间的最佳路径选择。
  
  数据链路层: 接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧
  
  物理层: 建立、维护、断开物理连接。传输比特流（将1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。
  ```

* tcp 报文首部有哪些字段

  ```
  源端口、目的端口：各占2个字节，表示数据从哪个进程来，去往哪个进程
  序号（Sequence Number）：占4个字节，TCP连接中传送的数据每一个字节都会有一个序号
  确认号（Acknowledgement Number）：占4个字节，另一方发送的tcp报文段的响应
  标志位 ： ack，seq
  窗口大小：占4个字节，用于TCP流量控制。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
  校验和：占2个字节，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。检验的范围包括头部、数据两部分，是TCP可靠传输的一个重要保障。
  ```

* Tcp 三次握手

  ```
  ```

* 为什么是3次握手，不是2次或者4次

  ```
  2次握手能保证单向连接建立。因为在发送 ack 包的同时也可以发送 seq 包，所以可以节省一次握手
  ```

* tcp 4次挥手

  ```
  第一次挥手：客户端向服务端发送连接释放报文 (fin_wait_1)(客户端)close_wait（服务端）
  第二次挥手：服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。 (fin_wait_2, 一方已经断了连接)  close_wait 服务端
  第三次挥手：服务端向客户端发送连接释放报文 （time_wait 客户端） last_ack (服务端)
  第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入CLOSED 状态。（close, close）
  ```

* 为什么需要4次挥手

  ```
  答案：TCP 是全双工。一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。
  ```

* 客户端 TIME-WAIT ，为什么要等待 2MSL 才进入 CLOSED 状态？

  ```
  MSL 是报文段在网络上最大存活时间。
  确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。
  如果客户端接收到服务端的重复包，会重新计算2msl
  ```

* 一台 8G 内存服务器，可以同时维护多少个连接？

  ```
  发送、接收缓存各4k，还要考虑socket描述符，一个tcp连接需要占用的最小内存是8k，那么最大连接数为：8*1024*1024 K / 8 K = 1048576 个，即约100万个tcp长连接。
  ```

* 什么是拆包

  ```
  传输层封包不能太大，基于这个限制，往往以缓冲区大小为单位，将数据拆分成多个 TCP 段（TCP Segment）传输。在接收数据的时候，一个个 TCP 段又被重组成原来的数据。简单来讲分为几个过程：拆分——传输——重组
  ```

* 什么是粘包

  ```
  解决数据太小问题，防止多次发送占用资源。TCP 协议将它们合并成一个 TCP 段发送，在目的地再还原成多个数据。
  ```

* 缓冲区的作用是什么

  ```
  缓冲区是在内存中开辟的一块区域，目的是缓冲。当应用频繁地通过网卡收、发数据，网卡只能一个一个处理。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。
  注意：TCP Segment 的大小不能超过缓冲区大小。
  缓冲不止是在http 这块，很多时候内存这些都有缓冲区，kafka 也是，攒了一定量后。flush 一次
  ```

* tcp 协议怎么保证数据的顺序

  ```
  大数据拆包成多个片段，发送可以保证有序，但是由于网络环境复杂，并不能保证它们到达时也是有序的，为了解决这个问题，对每个片段用Sequence Number编号，接收数据的时候，通过 Seq 进行排序。
  
  注意：seq是累计的发送字节数
  ```

* Tcp 如何解决丢包问题

  ```
  答案：丢包需要重发，关键是如何判断有没有丢包！
  
  每一个数据包，接收方都会给发送方发响应。每个 TCP 段发送时，接收方已经接收了多少数据，用 Acknowledgement Number（简写ACK） 表示。
  
  注意：ack是累计的接收字节数，表示这个包之前的包都已经收到了。
  
  每次发送一个包。都会受到一个应答包。然后这个包上还可以顺便携带数据包内容。
  ```

* 什么是 mss

  ```
  MSS 全称 Maximun Segment Size。是TCP Header 中的可选项（Options），控制了 TCP 段的大小，不能由单方决定，需要双方协商。
  ```

* tcp 协议如何控制流量传输速度

  ```
  简单讲通过滑动窗口。发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，吞吐量也就越大。但是窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。
  TCP每个请求都要有响应，如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。为了提升吞吐量，一个TCP段再没有收到响应时，可以继续发送下一个段。
  窗口区域包含两类数据：已发送未确认、未发送（即将发送）
  窗口中序号最小的分组如果收到 ACK，窗口就会向右滑动
  滑动窗口的size规格可能会变化，需要从ACK数据包实时取最新值
  如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送
  ```

* http 1.0 1.1 和 2.0的区别

  ```
  HTTP 1.0
  默认是短连接，每次与服务器交互，都需要新开一个连接。
  
  
  2、HTTP 1.1
  默认持久化连接，建立一次连接，多次请求均由这个连接完成。
  
  3、HTTP 2.0
  二进制分帧：在应用层和传输层之间加了一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码。减少服务端的压力，内存占用更少，连接吞吐量更大
  多路复用：允许同时通过单一的HTTP/2.0连接发起多次的请求-响应消息。
  头部压缩：采用了Hpack头部压缩算法对Header进行压缩，减少重复发送。
  服务器推送：服务器主动将一些资源推送给浏览器并缓存起来。
  
  http 2.0相比较 1.1 ， 1.1 更像 pipline, 其中一个连接中的一系列请求的阻塞还是会影响后续的请求的。
  2.0 更像是异步io， 通过 epoll 的方式主动监听变动的socket read write 事件， 再做对应的逻辑处理
  ```

* http 和 https 的区别

  ```
  答案：HTTPS = HTTP + SSL/TLS
  
  HTTP 采用明文通讯；端口 80
  HTTPS 在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。端口 443
  ```

* http 协议为什么要设计成无状态

  ```
  答案：HTTP是一种无状态协议，每个请求都是独立执行，请求/响应。这样设计的重要原因是，降低架构设计复杂度，毕竟服务器一旦带上了状态，扩容、缩容、路由都会受到制约 (比如路由上的session， 我们如果在服务器端存储，就可能因为负载均衡在另一台服务器上找寻不到信息)。无状态协议不要求服务器在多个请求期间保留每个用户的信息。
  
  但，你可能会问，如果有登录要求的业务怎么办？HTTP协议提供扩展机制，Header中增加了Cookie，存储在客户端，每次请求时自动携带，采用空间换时间机制，满足上下请求关联。虽然浪费了些网络带宽，但是减少了复杂度。当然为了减轻网络负担，浏览器会限制Cookie的大小，不同浏览器的限制标准略有差异，如：Chrome 10，限制最多 180个，每个Cookie大小不能超过 4096 bytes （现在一般用的jwt）
  ```

* https 的访问流程是什么

  ```
  客户端发起一个http请求，告诉服务器自己支持哪些hash算法。
  服务端把自己的信息以数字证书的形式返回给客户端（公钥在证书里面，私钥由服务器持有）。
  客户端收到服务器的响应后会先验证证书的合法性（证书的信息，通过之前的hash 算法得到一个字符串，然后利用操作系统自带的证书公钥去解析证书中被服务器私钥加密的字符串，得到另一个hash 值，利用上面的第一次hash 过的内容和 这个 hash 值对比，如果一致，说明证书安全）
  如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
  客户端将证书公钥加密后的密钥发送给服务端
  服务端用私钥解密，解密之后就得到客户端的密钥
  然后，客户端与服务端就靠密钥完成明文加密、安全通信、对称解密
  ```

* http 和 rpc 的区别

  ```
  通信协议不是rpc 最重要的部分 (https://www.zhihu.com/question/41609070)
  
  首先 http 和 rpc 并不是一个并行概念。rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。
  1.传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。
  2.序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。
  
  首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。
  
  简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。所以为什么要用rpc调用？因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。
  ```

  



cookie 和 session

```
服务端生成cookie返回给客户端，客户端请求带着cookie，
    
服务端获取cookie和session_id,然后读取session文件，就可以对比客户端的cookie了。 session是依附于cookie的，需要cookie来存储session_id。当禁用cookie的时候，通过url重写或者表单隐藏域来提交session_id

```



Sql 注入，xss， csrf

```
sql注入，用户输入sql命令或者sql注释，拼接sql的时候，会查出所有的用户信息。
防范：是过滤用户输入，使用预处理来拼接sql
    
 xss跨站脚本：网页中注入恶性脚本。持久型是存入到数据库，读出的时候弹出恶意代码，
 防范：用户输入过滤
    
csrf:跨站请求伪造。拿到A的cookie,访问恶意网站b，b就可以拿着a的cookie去访问a网站。
 防范：token机制，验证referer
```



git pull  和 git fetch 的区别

```
答：都是更新远程代码到本地
    （1）git pull相当于暴力合并，直接拉取代码，并合并，相当于git fetch + git merge
    (2)git fetch(下载)拉取代码后，一般需要手动合并下代码
    
我一般都是 git fetch ，然后本地自己合并    
```





* tcp 和 udp 的区别

  ```
  tcp 面向连接，udp 不建立连接
  tcp 可靠，udp 不可靠
  tcp 1v1， udp 1v多，可以广播
  tcp 滑动窗口，慢启动 用来拥塞控制，udp 没有
  tcp 通过重传，序列号保证顺序，udp 没有
  tcp 面向字节流，udp 面向报文 （应用层报文不处理，加上头部信息就给下层）
  ```



* 统计用户访问次数

  ```
  cat xxx.log | grep xxx | awk 切割文件 | sort | unique 聚合 （必须得sort 之后） | sort 排序 | wc -l 多少行
  ```

* http 304

  ```
  not modified
  客户端的缓存文件还能用，用的是之前缓存的内容 （304 也是服务端的返回）
  ```

* 502 504

  ```
  一般后台挂了502
  
  超时的时候显示 504
  ```

  
