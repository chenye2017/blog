* 数组

  ```
  特点：
  连续内存空间
  相同数据类型 （java 有泛型数组，golang 也开始支持泛型了， golang泛型和interface{} 的区别）
  线性结构
  
  有点：
  随机访问。为什么呢？因为他的类型固定，决定它的数据长度也就固定，另外就是连续，所以基于初始地址，可以直接计算出数组任意位置的内存地址。查询速度很多。
  （连续 + 类型固定 ===> 数组长度固定 num* size+ start =  end）
  
  缺点：
  为了保持连续性，中间位置插入或删除数据，需要做数据搬移，效率会较低。可以看下ArrayList相关API的源码
  成也萧何败萧何，数组初始化需要连续的内存空间，如果空间不够怎么办，扩容（golang slice）。使用数组要担心越界问题，因为是连续空间，所以我们要提前知道大小。（现在想想 slice 的panic 是合理的，slice 也只有在 append 的时候才会动态扩容，平时我们直接取值的时候会直接panic）
  
  ```

* 链表

  ```
  链表一种非连续、非顺序的存储结构，由一系列节点组成，节点间通过指针完成了串联，每个节点包含数据和下一个节点指针两部分。
  
  
  优点：
  不需要连续的内存空间，较灵活
  允许插入、删除链表上任意位置的节点，只需要修改指针的值，不需要像数组一样搬移数据，系统开销成本大大降低
  
  缺点:
  链表除了存储数据，还要存储指针，会额外占用一些存储空间
  由于非顺序存储，所以不支持随机存取 (访问元素 o(n)的复杂度)
  ```

* 栈

  ```
  又名堆栈，它是一种运算受限的线性表。上面成为栈顶，下面称为栈底。向栈插入新元素称为入栈，新元素放到栈顶；从一个栈删除元素又称作出栈，它是把栈顶元素删除掉，使其下面相邻的元素成为新的栈顶元素。
  
  优势
  只能操作栈顶元素，规则限制的死死地，不像其他数据结构非常灵活，可控性好，非常适合一些特殊业务场景。 括号的匹配
  
  我们平时经常会用语言自带的高级数据结构去模拟这些底层结构，比如 slice 只有尾部可以插入删除就能模拟 栈
  
  ```

* 队列

  ```
  队列是一种特殊的线性表，只允许在表的前端进行删除操作，而在表的后端进行插入操作。和栈一样，队列是一种操作受限制的线性表。插入的数据放在队尾，读取数据的端称为队头。队列中没有元素时，称为空队列
  
  真的都是可以通过 数组模拟，去除掉数组的 随机访问。
  
  优势：
  规则固定，头部只能读取，插入只能在队尾进行，规则固定，可控性&安全性好。非常适合一些特殊业务场景
  
  场景：
  java线程池ThreadPoolExecutor，来不及处理的任务会临时放在任务队列中
  各种MQ消息中间件，如：kafka、RocketMQ 等
  redis 消息队列
  ```

* 哈希表 (竟然也是一种数据结构)

  ```
  哈希表（Hash table）也叫散列表。根据键（Key）而直接访问在内存储存位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，加快查找速度。这个映射函数称为散列函数，存放记录的数组称做散列表。
  划重点：
  
  Hash函数，建立key与value的映射关系。
  常用的哈希函数有MD5、SHA、CRC等
  优势：
  
  分为治之，化大为小，降低了复杂度
  通过key计算直接获取目标位置，提高查找速度
  
  可能存在哈希冲突，在每个冲突处构建链表，将所有冲突值链入链表。如果是恶意攻击，哈希表可能会退化为链表，所有元素都被存储在同一个节点的链表中，此时哈希表的查找速度=链表遍历查找速度=O(n)
  
  为了描述冲突，引入装载因子=哈希表中的元素个数 / 哈希表长度，装载因子越大，说明链表的长度越长，性能会越低。
  （感觉哈希表这个数组需要的连续空间挺大）
  
  当装载因子过大时，需要动态扩容。申请一个更大的哈希表，将原哈希表的数据迁移到新的哈希表。
  
  使用场景
  
  Redis 数据库 （redis 本身就是）
  Java中的哈希表实现，HashMap （哈希表是原理， hashmap是对于哈希表的一种实现）
  ```
  
* 图

  ```
  淦  看不懂
  ```

* 树

  ```
  顾名思义，跟现实的树一样，树上的每一个元素成为节点，节点与节点之间有一定的关系，上下称为父子节点，左右称为兄弟节点。
  
  按照树的表现结构，可以具体分为以下几种类型：二叉树、平衡二叉树、满二叉树、完全二叉树、递归树、红黑树、B- 树、B+ 树 ，等
  
  
  红黑树出镜率很高，风头甚至盖过了平衡二叉树，因为红黑树只要求近似平衡，维护成本比AVL树要低，但性能损失不大。当HashMap中的链表数据较多时，也会将链表结构升级为红黑树结构。
  B+树主要是采用更加扁平的结构存储海量数据，降低树的深度，主要用在 mysql 数据库索引构建，有兴趣同学可以看下之前的文章
  
  
  
  ```

* 堆

  ```
  一种特殊的二叉树。需要满足两个条件：1、是一棵完全二叉树 2、堆中每个节点的值必须>=或<=其左右子节点的值。
  
  划重点：
  
  节点的值要比左右子树的值大或小，只能一种选择
  优势：
  
  时间复杂度较低
  获取堆顶元素的时间复杂度为 O(1)
  假设完全二叉树包含n个节点，插入元素、删除元素，时间复杂度为 O(logn)
  缺点：
  
  特殊的二叉树
  只能满足特殊的需求
  典型场景：
  
  堆排序
  优先级队列 (这个是什么呢)
  求 TOP K 
  求中位数
  
  
  从10亿个数据中s找到最大的前10个？
  
  假设10亿个数据存在数组中
  取前10个数据，构建一个小顶堆，那么根节点是最小的
  然后，从数组中依次取出一个数据与堆顶比较，如果大于，替换掉堆顶元素，堆内部调整；如果小于等于堆顶，不做处理
  同样逻辑，依次循环处理数组中每一个元素
  当10亿个数据处理完后，堆中的数据就是Top 10
  ```

  

一大堆元素中，求最大的n个数（分治，大顶堆）    

```
1）分治+大顶堆排序   
2）小顶堆，然后遍历，每次跟小顶堆的元素做对比，小的废弃。 大于的话，就把这个大的元素入堆即可。最终结果就是小顶堆。
```

查找第k 大元素

```
```

* 红黑树和二叉树的区别，性能为什么二叉树更好

  ```
  红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，
  复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，
  插入、删除、查找操作的时间复杂度都是 O(logn)。
  
  AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，
  AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，
  就比较复杂、耗时
  AVL树的查询性能更稳定，如果更新频繁的话，红黑树更好。
  （1）红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，
      也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，
   （2）红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，
       而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持
       平衡的开销要小得多
  
  ```

  

* 14亿个数的排序，求出第1亿个数是多少

  ```
  ```

* 快速排序

  ```
  ```

* lru 和 lfu

  ```
  https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/
  
  
  
  lru 查找快 （hash表，map），删除快 （链表） => hash 链表 （和 redis 那个 hash 冲突还不一样）
  lfu
  ```

  ![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/img/20210913001405.png)



* 让你设计一个框架，主要模块有哪些，怎么设计路由更高效

  ```
  ```

* 二叉树的非递归前序遍历

  ```
  ```

* 反转链表是怎么反转的

  ```
  ```

* 有序数组里面查询某个值出现的次数

  ```
  二分获取索引位置，双指针从索引位置左右遍历
  ```

* 14亿个数排序，第一亿个数是多少

  ```
  ```

* m 个有序数组合并

* 一大堆元素，求最大的n个数

* 查找第k大元素

* 红黑树和 avl 树的区别，为什么性能比二叉树好



* 排序

  ```
  https://www.cxyxiaowu.com/2573.html 稳定和非稳定排序
  
  1.冒泡排序 （稳定排序）n2
  func Bubble(arr []int) []int{
  	c := len(arr)
  	// 上浮大的数据
  	for i:=0;i <c-1; i++ {
  		for j:=0; j<c-1-i; j++ {
  			if arr[j] > arr[j+1] {
  				arr[j], arr[j+1] = arr[j+1], arr[j]
  			}
  		}
  	}
  	return arr
  }
  
  
  2.快速排序 (不稳定排序, 交换元素的时候) nlogn 不好情况 n2 
  
  func Quick(arr []int, low int , high int)  {
  	p := Q1(arr, low, high)
  	fmt.Println(p, "---pppppp--")
  	if p > 1 {
  		Quick(arr[low:p], low, len(arr[low:p])-1)
  	}
  	if p +1 < high {
  		Quick(arr[p+1:], p+1, len(arr[p+1:])-1)
  	}
  }
  
  //[]int{2, 44,0, 4, 8, 33, 1, 22}
  func Q1(arr []int, low int, high int) int{
  	c := len(arr)
  	if c <= 1 {
  		return 0
  	}
  
  	base := arr[low]
  	fmt.Println(base, "base")
  
  	for low < high {
  		for {
  			fmt.Println(low, high, "-----")
  			time.Sleep(time.Second)
  			if low < high {
  				if arr[high] > base {
  					high--
  				} else {
  
  					arr[low] = arr[high]
  					fmt.Println("swap high", arr)
  					break
  				}
  			} else {
  				break
  			}
  		}
  
  		for {
  			time.Sleep(time.Second)
  			if low < high {
  				if arr[low] < base {
  					low++
  				} else {
  					arr[high] = arr[low]
  					fmt.Println("swap low", arr)
  					break
  				}
  			} else {
  				break
  			}
  		}
  	}
  	arr[low] = base
  	fmt.Println(arr, "eeeee")
  	return low
  }
  
  
  3.
  
  
  ```

  



