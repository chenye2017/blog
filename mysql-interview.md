* 索引是什么

  ```
  索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
  
  索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。
  
  MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。
  ```

* 索引有哪些优缺点

  ```
  索引的优点
  
  可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
  索引的缺点
  
  时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
  空间方面：索引需要占物理空间。
  ```

* mysql 有哪几种索引类型

  ```
  1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引 (等值匹配)，full-index全文索引 （用的少），R-Tree （没用过）索引。这里所描述的是索引存储时保存的形式，
  
  2、从应用层次来分：普通索引，唯一索引，复合索引。
  
  普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
  
  唯一索引：索引列的值必须唯一，但允许有空值
  
  复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
  
  聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
  
  非聚簇索引：不是聚簇索引，就是非聚簇索引
  
  3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。
  ```

* 索引的底层实现

  ```
  Hash索引
  
  基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。
  
  B-Tree索引（MySQL使用B+Tree）
  B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。
  
  
  B+Tree索引 (感觉最明显的对比就是 b+ 的非叶子不存储额外的非索引列的信息)
  
  是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。
  
  B+tree性质：
  
  n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
  
  所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
  
  所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
  B+ 树中，数据对象的插入和删除仅在叶节点上进行。
  B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。
  ```

* 为什么索引结构默认使用b+ ,而不是b-, hash, 二叉树，红黑树

  ```
  ```

* mysql 和 redis 数据一致性保证

  ```
  http://www.xiaerblog.com/articles/2021/07/19/1626624020709.html
  
  既然用了缓存，就不能强一致性，毕竟 sql 和 cache 不是原子性操作，如果强制原子性，性能损耗也太大。
  
  弱一致性 --》 最终一致性。
  
  集中式redis 缓存的三个经典模式
  
  1.cache-aside pattern
  
  写数据：写db， 删缓存。 （如果先删除缓存，容易在写db 的时候，又写进去脏的缓存）
  
  读数据： 先读缓存，有直接返回，没有，读db， 设置缓存。
  
  
  2. read/write-through
  
  我们这边的永久缓存用的就是这种方式。对外暴露一个 cache provider， 其实每次写入都会往db 写一条数据
  
  3. write behind 异步写入
  
  异步写入，还能合并 cache 方法。
  
  
  是否可以先操作缓存。 
  
  可以的，延迟双删除。
  删除缓存就可能存在 失败，失败就要重试，可以通过消息队列。
  删除缓存就容易缓存穿透，可以利用single flight 解决这个问题。
  删除缓存，可以通过监听binlog 去解决。这样既不用 担心失败重试的问题，也不用担心每个地方都要侵入代码，多加删除redis 的代码。
  ```




mysql 执行sql 流程

```
```

mysql 的事务如何优化提升速度

```
通过减小锁粒度和减少锁的持有时间进行调优
    （1）结合业务场景，使用低级别事务隔离
    （2）sql优化避免行锁升级表锁
    （3）更新等行锁操作放到事务后面，尽量减少持有锁的时间。
        比如我们先创建订单，执行逻辑，最后扣除库存。
```



* explain 分析的时候要注意哪些

  ```
  select
  _type 其实可以根据 sql 语句判断出来大致是不是简单查询
  
  type ： ref where条件匹配， const 唯一主键匹配， all 全表扫描
  
  key 
  
  possible_key , 用到的那些索引
  
  rows， 实际查找的行数
  
  key_len, 关联索引的时候知道用到哪些列
  
  extra  一些排序规则
  
  ```

* Sql 优化

  ```
  1. 函数操作
  2. 隐式操作 （这个一定要注意，不止是在dms 上会不注意，代码中也容易不注意，特别是php 这种弱类型语言）
  3. 模糊查询 （注意只能 aa%）
  4. 计算操作 （field 我们一定不要随便操作）
  5. 范围查询 （单次查询量过大，会不走索引。可以分成两次查询，这个还蛮实用）
  ```

* count(*) count(1)  count(a ) 区别， 怎么优化

  ```
  count(*) 和 count(1) 是一样的
  
  count(a) 会忽略 null 类型
  
  count(*) 现在默认都走可以的二级索引 （因为聚簇索引叶子节点中值过大）
  
  myisam count(*)之所以快，是因为有记录。
  
  如果不需要很明确的，可以利用
  
  1.redis 计数
  2. innodb 新增表记录
  3.show table status （误差比较大）
  
  上面这些方案其实都不能加where 条件查询，没多大意义。
  ```

* b 树， b+ 树 是什么

  ```
  二分查找和适合索引，但是二叉树高度如果节点分布不均匀，容易形成链表，于是出现了二叉平衡树，因为节点过高，所以出现了 多叉树，b数，也就是二分搜索树。 b树上节点不重复，但非叶子节点（数据页上存储了节点的信息，造成页上可能存储的key 不均匀 和 过小）， 于是出现了b+树 。只在叶子节点上存储节点value， 然后非叶子节点的值可能与 叶子节点key 值重复
  
  ```

* 添加索引的场景

  ```
  数据检索时在条件字段添加索引
  聚合函数对聚合字段添加索引
  对排序字段添加索引
  为了防止回表添加索引
  关联查询在关联字段添加索引
  ```

* 普通索引和唯一索引有哪些区别

  ```
  ```

* 联合索引

  ```
  最左前缀，一定要注意前面如果是有顺序的才能用到后面的索引
  ```

* 各类型占索引大小

  ```
  这里补充一下 key_len 相关知识点： (null + 1 字节， 变长 + 2 字节)
  
  注意 char （指的是 字符，如果换算成字节 * 3）
  
  explain 中的 key_len 列用于表示这次查询中，所选择的索引长度有多少字节，常用于判断联合索引有多少列被选择了。下表总结了常用字段类型的 key_len：
  
  列类型	KEY_LEN	备注
  int	key_len = 4+1	int 为 4 bytes，允许为 NULL，加 1 byte
  int not null	key_len = 4	不允许为 NULL
  bigint	key_len=8+1	bigint 为 8 bytes，允许为 NULL 加 1 byte
  bigint not null	key_len=8	bigint 为 8 bytes
  char(30) utf8	key_len=30*3+1	char(n)为：n * 3 ，允许为 NULL 加 1 byte
  char(30) not null utf8	key_len=30*3	不允许为 NULL
  varchar(30) not null utf8	key_len=30*3+2	utf8 每个字符为 3 bytes，变长数据类型,加 2 bytes
  varchar(30) utf8	key_len=30*3+2+1	utf8 每个字符为 3 bytes，允许为 NULL,加 1 byte,变长数据类型，加 2 bytes
  datetime	key_len=8+1 (MySQL 5.6.4之前的版本)；key_len=5+1(MySQL 5.6.4及之后的版本)	允许为 NULL，加 1 byte
  ```

*  Cardinality

  ```
  这个区分度，一般都不会看，我们都只到 sex 不容易区分，但有一点我们需要了解的是，b+树上的节点都是 页，而不是真实的记录，他这块取的是 页上的所有记录进行统计。们知道了它的值只是一个估值，因此当我们遇到它的值与实际值相差很大时，可以考虑使用：analyze table xxx; 重新获取统计信息。
  ```

* force index， 强制走索引

*  mysql 三大日志

  ```
  https://juejin.cn/post/6860252224930070536
  
  binglog
  redolog
  undolog
  ```



* myisam 和 innodb 的区别

  ```
  1. myisam 不支持事务和行级锁 (表锁)，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。
  
  2. innodb是基于聚簇索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。
  ```

* 说下mysql 的索引有哪些，聚簇索引和非聚簇索引又是什么

  ```
  B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。
  ```

  ![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/img/20210907000551.png)



* 什么是覆盖索引和回表

  ```
  覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。
  
  而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。(这个倒是不知道， 平时只靠肉眼判断)
  ```

* 锁的类型有哪些

  ```
  mysql锁分为共享锁和排他锁，也叫做读锁和写锁。
  
  读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。
  
  写锁是排他的，它会阻塞其他的写锁和读锁。
  
  平时好像 写锁用的比较多
  
  从颗粒度来区分，可以分为表锁和行锁两种。
  
  表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。（但我们现在业务的平时 也是可以 ddl 语句的， 问问dba 为啥）
  
  行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现 （es 中用的比较多）。
  
  所以mysql 中用到的大部分是 悲观锁，颗粒度是 行锁，然后如果没有索引可能就全表锁了
  
  （为了支持 可重复读，又演变出了间隙锁， record 锁 = 间隙锁 + 行锁）
  ```

* 你能说下事务的基本特性和隔离级别么

  ```
  原子性  （一个事务中的操作要么全部成功，要么全部失败， 靠的就是 undo 日志的回滚功能更）
  
  一致性   （据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。​）(代码层面维护)
  
  隔离性   （一个事务的修改在最终提交前，对其他事务是不可见的。​mvcc 利用 快照 和 事务 id 去维护）
  
  持久性  （指的是一旦事务提交，所做的修改就会永久保存到数据库中 ，持久性内存 + redo 日志落库， 事务提交的时候通过redo log --》用户态内存 -》fsync 同步 ）
  
  隔离级别 ：
  
  读未提交， （脏读）
  
  读已提交，  （不可重复读， 靠当前读，每次读取之前做一张快照，就能解决）
  
  可重复读，  （幻读），幻读和 不可重复读主要区别是 不可重复读是数据修改，幻读是数据新增） （快照读，事务开始的时候 就搞一张快照）
  
  串行化
  
  
  innodb 通过 mvcc， 解决了 可重复读下面 幻读问题。
  
  读已提交 （事务中，读取数据，加 读锁， 另一个事务中， 修改同一个数据，写锁，不会阻塞么。
  
  不会，读写语句的时候好像并不会加排它锁和共享锁
  
  ）
  
  ```



* 快照读和当前读的区别

  ```
  ```

* 什么是幻读，什么是 mvcc

  ```
  ```

* 什么是间隙锁

  ```
  ```

* 你们数据量级多大 ？ 分库分表怎么做的

  ```
  分库：
  业务分库。渠道业务和订单业务分库，分布在不同的数据库实例上，不会相互被影响，增加数据库链接的时候也方便扩容。
  读写分离，读从库，写实库。读写延迟。（如果要求高的，读主库。又或者写入延迟队列再执行。调整参数，减少延迟时间）
  
  
  垂直分表
  把一些冷字段，大字段拆出来
  
  水平分表
  1. （某个field hash）首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。
  
  比如用户id为100，那我们都经过hash(100)，然后对1024（）取模，就可以落到对应的表上了。
  
  2. 时间片 ，容易不均匀
  3. id 步长 （感觉和上面时间片差不多，但相比于时间片应该更均匀）
  ```

* 分表后的id 怎么保证唯一性

  ```
  因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：
  
  1.设定步长，比如1-1024张表我们设定1024的基础步长，这样主键落到不同的表就不会冲突了
  2.分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种 
  3.redis incr
  
  ```
  
* 分表后非shared_key 怎么处理

  ```
  可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。
  打宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，或者基于其他如es提供查询服务。
  ```

* mysql 主从同步怎么做的

   ```
   首先先了解mysql主从同步的原理
   
   master提交完事务后，写入binlog
   slave连接到master，获取binlog
   master创建dump线程，推送binglog到slave
   slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中
   slave再开启一个sql线程读取relay log事件并在slave执行，完成同步
   slave记录自己的binglog
   
   
   下面这两种就和 kafka 是一样的
   由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。
   
   全同步复制
   
   主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
   
   半同步复制
   
   和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。
   
   ```

![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/img/20210907005622.png)



* 主从延迟怎么解决

  ```
  1.强制走主库查询
  2.后台job任务，先写到延迟队列，在处理
  3.调整参数，比如buffer 大小，优化主从延迟的时间
  ```

* mysql redo log 的写入过程

  ```
  ```

* Mysql 主从不一致怎么优化

  ```
  https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/83067200
  1、利用多线程重放 relaylog （考虑顺序，多线程执行不同表上的更新操作）（relaylog 包括 update， insert ，delete）
  
  ```

* mysql 主从不一致怎么解决

  ```
  强制读主库
  ```

* mysql 的undo 日志原理，中继日志干嘛的

  ```
  ```

* mysql 的 mvcc 实现原理

  ```
  ```

* 死锁的避免

  ```
  1.按照同一个顺序访问对象
  2.事务尽可能简短，访问完释放
  ```

  





id   粉丝_id  明星_id  根据 粉丝id 拆表， 可以查询到 我关注了那些 明星



某个明星有哪些粉丝，反查询肯定不行，











xxxxxxxxxx 通过减小锁粒度和减少锁的持有时间进行调优    （1）结合业务场景，使用低级别事务隔离    （2）sql优化避免行锁升级表锁    （3）更新等行锁操作放到事务后面，尽量减少持有锁的时间。        比如我们先创建订单，执行逻辑，最后扣除库存。

