事件发生是某天晚上， 某个服务大量重启，日志显示内容也只有 ![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20221008150003.png)

这对于我们的任务排查无疑大海捞针， 因为panic 没有堆栈信息，我们并不能马上定位到错误代码的位置进行问题排查。panic 会杀死当前进程，导致服务重启，重启后又panic，又重启陷入死循环， 无疑当前的事故是灾难级别。一般我们遇到问题最快的解决办法就是回滚，因为假期到来，最近很久没有发版，所以很可能是一个隐藏的很深的bug，如果贸然回滚最新的版本，首先错误不一定能解决，再有这是一个底层服务， 如果回滚了，无疑对上层调用的服务影响很大。

先来介绍一下这个服务的背景：当前直播营收这边会有很多的异步任务需要处理，一般我们这样接受消息

```
client := mq.New(conf)

for {
  select {
  case <-client.Msg:
     doSomething()
  case <-finish.Channel:
		 goto end
  }
}

end:
   fmt.Println("finish")
```

比如购买完大航海， 1.发放主站装扮， 2.增加粉丝等级  , 3.完成某个主播任务 等。一种方案是这个消费者在 大航海服务这边维护。比如任务组产品某天希望购买完大航海新增另一个任务，大航海的开发就新加一个消费者，但因为任务组和大航海的开发很大可能性不在一个组，对于排期开发会比较难协同。一般都会使用另一种方案，大航海投出消息，消费者靠各个业务方去接，如果想新增，自己增加一个消费者。（题外话：这样会出现另一个问题，消费者很难收拢到一个地方如果代码不在同一个仓库下，以后代码重构梳理链路流程，灾难级别。b站这边的处理方式是通过代码中增加caller 标记，我们可以很清晰的在业务监控上看到）因为消费靠各个业务方维护，我们就会要写很多重复的上面的代码，还有一点就是消息的分类 。比如营收消息。送礼是一个topic 产出，抽奖是另一个topic 产出， 我们在统计用户消费和主播收益的时候都需要上面两个消息的和，如果我们一个一个的接，代码容易重复。在上面的背景下，我们这次panic 的主角服务产生。 他的主要任务就是 监听多个topic ，把消息进行分类，然后通过协程的方式调用下游，自身没有任何逻辑，其实就是调度的作用。同时他还有增加了消息重试，分快慢队列，如果一次消费失败可以进入重试快队列，多次失败会进入慢队列。

上面的panic 最主要的影响就是我们消费的延迟，进而是消息的堆积 。因为一直重启，我们消息得不到及时处理 ，因为kafka 本质是通过offset 标记消费进度的，所以其实短时间内消息的堆积倒是没什么问题 。

这个服务提供的对外http 很少，我们初步怀疑还是某个消息格式有问题，代码中对这个消息的兼容性不好，所以导致panic。

我们处理消息有先提交，再处理。 或者是 先处理，再提交。一般我们是先处理，再提交，因为如果处理有问题，我们可以重试过后再提交，叫上消息的失败率。但可能因为一直panic， 导致流程走不到commit 那一步，服务重启后又消费同一条消息，又重启，所以此时我们先提交，再处理，把错误消息滤掉，可以暂时解决问题。我们做了下修改，版本发布，服务正常，看来真有脏消息。



怎么寻找有问题的代码，

我们注意到panic 的位置有打印地址，通过 https://blog.csdn.net/ab0902cd/article/details/107842903， 可以寻找。

![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20221104151437.png)

![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20221104152510.png)

```
1.去nyx上下载构建包
2.把可执行文件（类似 guard.exe 之所以取名exe 是为了突出他是可执行文件）上传到服务器上，有 arr2line 的服务器上，已知我们的27 堡垒机上有。
3. 执行 addr2line -e main {$pc} -f -a -p -C 。 其中的main 就是我们的可执行文件， {$pc}是我们的panic 地址。

题外话：
1.怎么安装 addrline
apt-get install binutils
2.上传可执行文件。 因为下载下来的可执行文件在我们自己的机器上，自己机器是没有公网ip的，之前我的做法是先把文件上传到我的私有服务器上，再利用 堡垒机可以访问外网的优势以我私有服务器的公网ip 下载，（上传下载都是通过scp）。b站有个工具

```







错误代码

![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20221008154736.png)

问题定位到entryRoom 的effectReq 是nil， 所以以后我们在使用 地址类型的属性的时候一定要记得 判断是否是nil (说起来很容易)， 或者用我们当前pb生成时候的get方法，他会提前判断effectReq 属性是否是nil， 如果是nil ，返回uid 的零值类型 （java php 这类面向对象的语言 会封装这类方法）

👆🏻是根源， 上面的代码利用 waitgroup 跑的，原生waitgroup 利用go 关键字开协程，多协程之间地位相等，没有互相管理的权限，一个崩掉会影响整个 go 的进程模型， 所以我们但凡遇到go 原生开协程，还是主动加一个 defer recover panic 并且打印堆栈， 否则后面真的panic 都找不到 原因。 更简单的方法就是 用errgroup 去替换waitgroup 。



好了以上就是整个事故的全过程，总结下很核心的点：

1.先commit ，防止服务继续重启，无法对外提供服务。但这个针对特定场景，并不通用，能感觉到到收获的就是我们遇到这种事情要冷静分析，如果找不到问题根源，凭借经验。

2.通过工具寻找错误代码位置，这个是核心，如果有堆栈，很容易就解决了。

3.原生go 关键字一定要注意panic， 使用地质类型变量一定要注意nil.